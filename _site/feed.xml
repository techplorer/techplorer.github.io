<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fusha Blog</title>
    <description>这里是 周海军 的个人博客</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 13 Nov 2022 08:45:03 +0800</pubDate>
    <lastBuildDate>Sun, 13 Nov 2022 08:45:03 +0800</lastBuildDate>
    <generator>Jekyll v4.2.2</generator>
    
      <item>
        <title>算法排序(快排)</title>
        <description>&lt;h3 id=&quot;算法简介&quot;&gt;算法简介&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;算法核心思想&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以升序排列为例，找一个基准值，让所有左边的元素小于等于该基准值，让右边的元素大于或等于该基准值；
如此一来，整个区间被分成两段：左半段和右半段，即左区间小于等于右区间，最后采用递归的方式分别对左区间、右区间执行同样的排序动作。&lt;/p&gt;

&lt;p&gt;相较于选择排序法，快排采用分区的方式优化了元素间的比较次数，某种程度上而言，快排也是一种基于选择排序法的一种剪枝优化。&lt;/p&gt;

&lt;p&gt;它的平均时间复杂度是O(n*logN)，最坏的情况下是O(N^2)，导致快排算法不稳定的一个重要因素在于分区，比如说对一个已经排好序的升序数组做快排，这种情况下因为区间只有一边，分区没有效果，算法复杂度退化为O(N^2)，而且这种情况下因为有递归调用，反而增加了一些时间开销。&lt;/p&gt;

&lt;p&gt;所以在快排的设计思路里边，分区是一个很重要的概念，在代码设计时应要考虑降低算法退化的可能性，尽可能的让算法效率趋于稳定。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;动图展示&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/zhouhaijun-pic/quick-sort-demo.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;代码演示基本功能&quot;&gt;代码演示基本功能&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;试图来写一个代码，完成快排的基本功能：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// define the interval rule: left is close and right is open ,e.g. [from, end)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// try to find the first element which bigger than pivot from left to right&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// try to find the first element which littler than pivot from right to left&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// check l and r, if l &amp;lt; r, then swap&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// whatever ,the last status will be: l == r&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// so swap l and pivot, then return l&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;QuickSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// terminator for loop ending&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;QuickSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;QuickSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;65&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;78&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;before sort:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;QuickSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;


  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;after sort:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;代码优化&lt;/p&gt;

    &lt;p&gt;上述代码存在几个问题：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;未实现泛型，主要体现在两个方面：一是采用了vector容器，二是限制了元素的类型，这个问题比较好解，用c++的模板就可以解决；&lt;/li&gt;
      &lt;li&gt;开篇提到的算法不稳定的问题，因为始终用第一个元素做基准值，极端的情况下算法会退化，要解决这个问题，可以用三端中值法，即取首、中、尾的中间元素作为基准值。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尝试提供一个优化后的版本：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;move_middle_to_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// [first, last)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;move_middle_to_first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;QuickSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;QuickSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;QuickSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;延深点&quot;&gt;延深点&lt;/h4&gt;

&lt;p&gt;以上只是讲述自己对快排的理解，相比于c++标准库提供的std::sort而言，我们自定义实现的快排程序，比起快排还要弱一些，主要是有一点没有考虑：当数据量比较小的时候，快排比插排还要慢一点，这是因为递归调用和元素腾挪的时间消耗，是有一个阈值的，所以c++标准库提供的sort函数在阈值小于一定数值的时候，会采用插入排序。&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Nov 2022 17:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/11/13/quick-sort/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/11/13/quick-sort/</guid>
        
        <category>算法</category>
        
        
      </item>
    
      <item>
        <title>多目标匹配(匈牙利算法)</title>
        <description>&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;

&lt;p&gt;二分图的最大匹配问题，在日常生活中也很常见，比如外卖场景，订单与骑手的匹配，滴滴网约车司机与乘客的匹配，都会用到二分图匹配算法，结合自己的思考聊聊二分图匹配问题。&lt;/p&gt;

&lt;h3 id=&quot;无向图最大边匹配&quot;&gt;无向图最大边匹配&lt;/h3&gt;

&lt;p&gt;为了便于描述，先来放一个无向二分图：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;我们先假设有两个不相交的集合S,S中含元素A、B、C，另一集合D，D中含元素a、b、c；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;S和D的元素之间的关系如上述图所示;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/in-post/zhouhaijun-pic/2022/multi-objects-match-1.jpeg&quot; alt=&quot;无向图&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如上图所示，我们要找出从S到D的最大匹配，该怎么实现呢？&lt;/p&gt;

&lt;p&gt;简单分析一下：&lt;/p&gt;

&lt;p&gt;因为是无向图，没有权重，所以我们要想让S和D实现最大的匹配，问题进一步转化为找图中的最大匹配边，不难看出，在这种场景下，核心的问题就在于如何解决目标匹配冲突，比如A和B同时可以选择a，那么到底选择的匹配边是A-a还是B-a。&lt;/p&gt;

&lt;p&gt;有一种思路是这样的：当发生目标匹配冲突时，比如A-a是已经匹配的边，此时B发现a也可以匹配，这时试图让A去找其他的目标，发现A可以与c匹配，那么匹配成功：B-a匹配，A-c匹配。A试图找其他目标和B找目标都是同样的过程，可以用计算机的递归来解决，分析到这里，整个问题就迎刃而解。&lt;/p&gt;

&lt;h3 id=&quot;匈牙利算法&quot;&gt;匈牙利算法&lt;/h3&gt;

&lt;p&gt;上述这个过程，其实就是匈牙利算法，比较粗糙，再来一个专业一点的描述：&lt;/p&gt;

&lt;p&gt;先定一个术语：增广路径：我们从集合S出发，去匹配集合D中的元素，按照未匹配的边-&amp;gt;匹配的边-&amp;gt;未匹配的边-&amp;gt;….-&amp;gt;未匹配的边，依次交替进行，最终形成一条路径，叫增广路径。&lt;/p&gt;

&lt;p&gt;增广路中的匹配边就是目标有冲突匹配的地方，解决的办法就是让发生冲突的顶点去找其他可能存在的匹配目标，所以整个匹配的过程，可以总结为如下过程：&lt;/p&gt;

&lt;p&gt;遍历集合S中的每个元素，与集合D中的每个元素匹配，尝试去找一条增广路，如果找到，说明匹配成功，如果没找到，则匹配失败。&lt;/p&gt;

&lt;p&gt;用图来描述一下过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/zhouhaijun-pic/2022/multi-objects-match-2.jpeg&quot; alt=&quot;图1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/zhouhaijun-pic/2022/multi-objects-match-3.jpeg&quot; alt=&quot;图2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/zhouhaijun-pic/2022/multi-objects-match-4.jpeg&quot; alt=&quot;图3&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;代码模板&quot;&gt;代码模板&lt;/h3&gt;

&lt;p&gt;结合代码，理解会更深刻一些：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

class Hungarian {

public:
  Hungarian(std::vector&amp;lt;std::vector&amp;lt;bool&amp;gt;&amp;gt; &amp;amp;g) {
    graph = std::move(g);

    maxLeftVertexNums = graph.size();
    maxRightVertexNums = graph[0].size();
    
    matchPairFromRight.reserve(maxRightVertexNums);
    for (int i = 0; i &amp;lt; maxRightVertexNums; ++i) {
      matchPairFromRight[i] = -1;
    }
    
    visitedRightVertex.reserve(maxRightVertexNums);

  }

  int MaxMatch() {
    int maxMatchEdges = 0;
    for (int i = 0; i &amp;lt; maxLeftVertexNums; ++i) {
      // 每一次match之前，要对visitedRightVertex做清零
      clearVisited();

      maxMatchEdges = find(i) ? (maxMatchEdges + 1) : maxMatchEdges;
    }
    
    return maxMatchEdges;

  }

  void print() {
    for (int i = 0; i &amp;lt; maxRightVertexNums; ++i) {
      std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; -&amp;gt; &quot; &amp;lt;&amp;lt; matchPairFromRight[i] &amp;lt;&amp;lt; std::endl;
    }
  }

private:
  void clearVisited() {
    for (int j = 0; j &amp;lt; maxRightVertexNums; ++j) {
      visitedRightVertex[j] = false;
    }
  }

  bool find(int srcVertexIdx) {
    for (int idx = 0; idx &amp;lt; maxRightVertexNums; ++idx) {
      if (graph[srcVertexIdx][idx] &amp;amp;&amp;amp; !visitedRightVertex[idx]) {
        visitedRightVertex[idx] = true;

        if (matchPairFromRight[idx] == -1 || find(matchPairFromRight[idx])) {
          matchPairFromRight[idx] = srcVertexIdx;
          return true;
        }
      }
    }
    
    return false;

  }

private:
  int maxLeftVertexNums = 0;
  int maxRightVertexNums = 0;

  /*

   * 假定我们有两个不相交的集合A和B，分别用左集合和右集合来区分，匹配的时候从左边集合向右表集合搜索，
   * 所以visitedRightVertex表示左集合顶点在一次搜索中有没有被访问，避免出现死递归
     */
       std::vector&amp;lt;bool&amp;gt; visitedRightVertex;

  /*

   * 表示左边集合中顶点有没有匹配到右边的顶点，存放的是节点的索引，如果没有匹配存放-1
     */
       std::vector&amp;lt;int&amp;gt; matchPairFromRight;

  std::vector&amp;lt;std::vector&amp;lt;bool&amp;gt;&amp;gt; graph; // 邻接矩阵
};

int main(void) {
  std::vector&amp;lt;std::vector&amp;lt;bool&amp;gt;&amp;gt; graph;
  graph.push_back({1, 1, 0});
  graph.push_back({1, 0, 0});
  graph.push_back({0, 1, 0});

  Hungarian h(graph);
  int matchNums = h.MaxMatch();
  std::cout &amp;lt;&amp;lt; &quot;match num:&quot; &amp;lt;&amp;lt; matchNums &amp;lt;&amp;lt; std::endl;
  h.print();

  return 0;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;匈牙利算法是解决二分图中的常用思路，但是我们发现其实这种算法没有考虑权重，即有向带权图，而我们生活中接触的问题都比较复杂，问题简化为有向带权图往往是一种更优的解决方案，下篇文章写一篇关于有向带权图的理解。&lt;/p&gt;
</description>
        <pubDate>Thu, 03 Nov 2022 06:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/11/03/multi-objects-match/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/11/03/multi-objects-match/</guid>
        
        <category>算法</category>
        
        
      </item>
    
      <item>
        <title>c++内存结构排列</title>
        <description>&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;

&lt;p&gt;前几天和同事讨论一个问题时，涉及到一个类数据布局的问题，对这块的理解有点模糊，回去后翻了一下《深度探索c++对象模型》这本书，做了一些实验验证了自己的想法，总结一下。&lt;/p&gt;

&lt;h3 id=&quot;类的内存排列&quot;&gt;类的内存排列&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;类数据结构排列&lt;/p&gt;

    &lt;p&gt;实际的的内存排列会因编译器有区别，这里只突出关键点:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/zhouhaijun-pic/2022/cc-memory-layout.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;测试代码&lt;/p&gt;

    &lt;p&gt;为方便描述，放一段测试代码：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;A...&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;B...&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){}&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;D....&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;111&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;继承和多态&quot;&gt;继承和多态&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;继承&lt;/p&gt;

    &lt;p&gt;类D公共继承A和B，类D的内存排列结构也是依次继承A和B，这一点很容易理解，要注意的一点是实际排列时需考虑字节对齐。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多态&lt;/p&gt;

    &lt;p&gt;多态稍微会麻烦一点，从两个角度来描述多态:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;构造函数初始化数据结构&lt;/p&gt;

        &lt;p&gt;首先一点要注意的是，只要类中有virtual函数，那么都会有一个对应的虚表，所以在本文中，A、B、D都有一个虚表：&lt;/p&gt;

        &lt;p&gt;对于类A和类B来说，这个构造过程主要分为两步：将虚表的地址赋给vptr、再依次初始化对应的成员数据;&lt;/p&gt;

        &lt;p&gt;对于继承自A、B的D来说，简单来说分成两步：第一步，先调用类A和类B的构造函数，第二步则和类A类B的初始化一样，即初始化vptr和成员数据。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;多态运行&lt;/p&gt;

        &lt;p&gt;多态在程序运行期，实际上时通过虚表的偏移完成的，通过一段测试代码和汇编代码，不难还原它的执行过程：&lt;/p&gt;

        &lt;p&gt;&lt;img src=&quot;/img/in-post/zhouhaijun-pic/2022/cc-memory-layout-1.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;类转换&quot;&gt;类转换&lt;/h3&gt;

&lt;p&gt;了解了类在内存中的布局，再来讨论一个与之相关的问题：类的upcast和downcast，即向上转换和向下转换，其中upcast是安全的，downcast是不安全的，这一点应该很好理解。&lt;/p&gt;

&lt;p&gt;c++提供了几种转换的方式，static_cast和dynamic_cast，从名字上容易看出来，static_cast用于编译期间，dynamic_cast用于运行期间，这里着重结合虚函数简单聊一下dynamic_cast。&lt;/p&gt;

&lt;p&gt;dynamic_cast我在平时工作的时候用的地方不多，有一种场景是下面这种：&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Base&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Base...&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Derived&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Base&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Derived&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Derived....&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Derived&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;C.....&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Derived&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Derived&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;dynamic_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Derived&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// okay&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Derived&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;dynamic_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// not okay&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;d1:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// actual address&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;d2:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 0x0&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结合汇编代码：&lt;img src=&quot;/img/in-post/zhouhaijun-pic/2022/cc-memory-layout-2.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;dynamic_cast传入了三个参数，类地址、源类型、目的类型:
源类型到目的类型的转换是我们的一个诉求，但能不能转换具体看的是第一个参数，准确的说是通过虚表找到类真正的类型：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Derived* d1 = dynamic_cast&amp;lt;Derived*&amp;gt;(b);
类地址: b
源类型: Base*
目的类型: Derived*
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;所以dynamic_cast要求一定要有虚函数，实际上就是通过虚表找到实际类型，在运行期间check是否满足转换要求：满足则返回实际地址，不满足返回空指针。&lt;/p&gt;
</description>
        <pubDate>Wed, 19 Oct 2022 16:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/10/19/cc-layout/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/10/19/cc-layout/</guid>
        
        <category>c++</category>
        
        
      </item>
    
      <item>
        <title>让进步每天发生</title>
        <description>&lt;p&gt;阿里人有句话，”让进步每天发生”，也算是老话术了，哈哈，其实仔细想想，还是有那么点道理的。&lt;/p&gt;

&lt;p&gt;从我现在的认知来看，如果想要成为一名合格的工程师，起码要具备三种能力，即快速的学习能力、深度思考问题的能力、很强的工程实践能力。这三种能力的习得也非一朝一夕的事，需要勤奋、坚持和刻意练习。&lt;/p&gt;

&lt;p&gt;正好下个月入职阿里快满1年了，前段时间和leader交流了一下，这一年的工作经历、成长与不足，交流中有一些心得体会，这里也总结记录一下。&lt;/p&gt;

&lt;h3 id=&quot;总结思考刻意练习&quot;&gt;总结、思考、刻意练习&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;多总结&lt;/p&gt;

    &lt;p&gt;这一点上，自己做的还可以，平时工作中不管遇到大问题还是小问题，都会及时写文档总结记录。&lt;/p&gt;

    &lt;p&gt;对我来说，写文档最大的好处在于梳理知识点，尝试用写文档的方式写出自己的理解，如果写不出来或者有卡壳，说明中间环节遇到盲区，这个时候抓住关键点，再需要回炉重造一遍，反复迭代。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多思考&lt;/p&gt;

    &lt;p&gt;多思考为什么，不管是工作还是生活中，保持思考的习惯，养成一种惯性。&lt;/p&gt;

    &lt;p&gt;工作中，代码为什么要这么写？这么写会不会有问题？有没有性能更好的写法？方案为什么要这么设计？它解决的痛点是什么？这样的方案会有哪些不足？有没有更好的方案？&lt;/p&gt;

    &lt;p&gt;生活中，多问为什么，为什么美元要加息？为什么中国要降息？&lt;/p&gt;

    &lt;p&gt;脑子是越动越灵活，一定要多思考，keep thinking，思考才是真正让自己进步的源动力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;刻意练习&lt;/p&gt;

    &lt;p&gt;总结、思考是牵引力，还有最关键的一环，在于刻意练习。&lt;/p&gt;

    &lt;p&gt;“学而不思则罔，思而不学则殆”，我认为学思结合最重要的一个环节，在于验证和闭环。对于做技术来说，就是要多动手，动手写代码、看源码、搭框架等等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;最后&quot;&gt;最后&lt;/h3&gt;

&lt;p&gt;最后，我觉得还有两个指引行动的纲领，也很重要：一个是保持好奇心，另外一个是高标准要求自己。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;保持好奇心&lt;/p&gt;

    &lt;p&gt;好奇心是驱使我们发现问题、解决问题的动力，没有好奇心，就很难发现新问题，一个对周边事物没有好奇心的人，大多数情况下会失去思考的动力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对自己要求高&lt;/p&gt;

    &lt;p&gt;高手过招，往往三两句话就能试探出对方水平，为什么会这样呢？往往是因为细节中可以捕捉到一个人做事的品质。自己觉得很难的问题，到了别人那里就是三言两语很轻松的事，这种要么就是大忽悠要么就是有绝对自信。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;扯远了，我觉得要想让进步每天发生，一定要做一个对自己要求高的人。拔高自己做事的标准，长期以往，刻意练习就会变成一种习惯，进而在细节上就会发生很大的变化。&lt;/p&gt;
</description>
        <pubDate>Tue, 18 Oct 2022 06:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/10/18/self-motivation/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/10/18/self-motivation/</guid>
        
        <category>感悟</category>
        
        
      </item>
    
      <item>
        <title>检索算法基础知识</title>
        <description>&lt;p&gt;检索算法的基础知识点，从数据结构和算法两个方面总结：&lt;/p&gt;
&lt;h3 id=&quot;线性结构检索&quot;&gt;线性结构检索&lt;/h3&gt;

&lt;p&gt;线性表，也就是数组，它的特点是数据连续存储，可以做到随机访问，数组排好序的前提下可以用二分法实现O(logN)的查找速度，缺点就是元素增删会导致数组扩容、重新排序，是会影响检索效率。&lt;/p&gt;

&lt;h3 id=&quot;非线形结构检索&quot;&gt;非线形结构检索&lt;/h3&gt;
&lt;p&gt;以单链表来说，它的特点是数据离散存储，增删操作不会有类似数组扩容的问题，但无法像数组那样做到随机访问。&lt;/p&gt;

&lt;p&gt;查找元素的复杂度是O(N)，但是我们也可以用二分法的思路来提速，这就涉及到二叉搜索树和跳表，查找时间复杂度提升到O(logN)。&lt;/p&gt;

&lt;p&gt;这样看起来的话，似乎二叉搜索树、跳表的实现要优于数组，但是在实际的工程里边，因为CPU局部性原理，连续数据的存储，在查找效率会比离散结构的高，因为数据离散，导致CPU cache miss的可能性也就越高。所以在小数据量的场景下，数组往往是一个更优的选择。&lt;/p&gt;

&lt;h3 id=&quot;哈希表&quot;&gt;哈希表&lt;/h3&gt;

&lt;p&gt;无论是有序数组还是二叉搜索树，查找速度都是O(logN)，有没有更快的检索算法呢？哈希表就是这么出来的，实现思路也很简单：设计一个散列函数(或者叫哈希函数)，建立key到数组下标的映射，再配合数组的随机访问的特点，可以实现O(1)的查找。&lt;/p&gt;

&lt;p&gt;但是哈希表也要处理一个棘手的问题，不管哈希函数设计的多么好，哈希冲撞是一件必然发生事件。所以哈希冲撞是一个绕不开的问题，处理哈希冲撞的解决方案目前主要有两种：开放地址和链表法。&lt;/p&gt;

&lt;p&gt;了解内部原理，其实也就能发现，哈希查找O(1)是一种理想值，往往具体的过程是这样：以链表冲突法为例，通过哈希函数找到对应的bucket桶，再对链表做一次遍历，这样下来查找效率往往没有O(1)，更何况还得考虑CPU cache miss的情况。&lt;/p&gt;

&lt;p&gt;这里也可以再引申一下，哈希的结构优化，以链表法冲突为例，为了加速查找，可以考虑设计一个阈值，在小于一定阈值的情况下用链表存储冲突元素，当大于一定阈值，将链表改为平衡树。&lt;/p&gt;

&lt;h3 id=&quot;位图&quot;&gt;位图&lt;/h3&gt;

&lt;p&gt;我们还会遇到一种比较常见的场景：在海量的大数据，想要尽可能快的查找一个元素是否存在，比如新用户注册id、网络爬虫URL判重等。&lt;/p&gt;

&lt;p&gt;在这种场景下，如果用哈希表存储，最大的问题在于存储效率，举例来说，如果要存储100亿个uint32的数据，得有37.2GB的存储空间，所以这里的逻辑在于：有没有一种结构，可以实现O(1)的查找，同时存储空间尽可能的小？&lt;/p&gt;

&lt;p&gt;位图就是这么来的，它的一个实现方案是：用一个连续的数组来存储，每一个bit通过0和1区分元素是否存在，使用一个哈希函数将元素映射到数组下标。采用这样的思路，同样是1亿个uint32的数据，我们只需要1.16GB，存储空间只有原来的3%。&lt;/p&gt;

&lt;p&gt;进一步的，位图的数据如果是不稠密的话，空间上还可以再压缩一下，常见的方案是roraing bitmap。&lt;/p&gt;
</description>
        <pubDate>Wed, 28 Sep 2022 06:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/09/28/search-algorithm-introduce/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/09/28/search-algorithm-introduce/</guid>
        
        <category>搜索与推荐</category>
        
        
      </item>
    
      <item>
        <title>浮点数除零</title>
        <description>&lt;h3 id=&quot;背景交代&quot;&gt;背景交代&lt;/h3&gt;

&lt;p&gt;前几天在工作上遇到一个浮点数除零的问题，暴露了自己知识点的不足，这里整理一下吧。&lt;/p&gt;

&lt;p&gt;浮点数除0会不会有异常呢？要回答这个问题，我们需要拆分成几个知识点。&lt;/p&gt;

&lt;h3 id=&quot;浮点数在计算机怎么存储&quot;&gt;浮点数在计算机怎么存储&lt;/h3&gt;
&lt;p&gt;有关浮点数在计算机的存储，IEEE754标准对此做了说明：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/zhouhaijun-pic/2022/float-ieee754.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;目前常用的两种表示方法：单精度浮点数、双精度浮点数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单精度浮点数，一共是32位，其中符号位占1位，指数部分占8位，尾数部分占23位；&lt;/li&gt;
  &lt;li&gt;双精度浮点数，一共是64位，其中符号位占1位，指数部分占11位，尾数部分占52位；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以单精度为例来说：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sign位为0表示正数，为1表示负数；&lt;/li&gt;
  &lt;li&gt;指数部分占8位，表示的范围是0～255，但是因为考虑到负数，所以能表达的范围就是-126～127，存储的时候127+指数；&lt;/li&gt;
  &lt;li&gt;尾数部分占23位；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里要提一下科学记数法，因为IEEE754里对浮点数存储的的规定是基于科学记数法的。&lt;/p&gt;

&lt;p&gt;先来看一下10进制的浮点数的科学计数法：&lt;/p&gt;

&lt;p&gt;3498523 = 3.498523×10^6&lt;/p&gt;

&lt;p&gt;−0.0432=−4.32×10^(−2)&lt;/p&gt;

&lt;p&gt;那么2进制下的浮点数该怎么表示呢？其实也是一样的道理，分别将整数和小数部分转为2进制即可，原理很简单，整数部分一直除2一直到整数为0截止，小数部分一直乘2一直到小数为0截止(乘不尽的保留指定位数)。&lt;/p&gt;

&lt;p&gt;举个例子来说，125.125&lt;/p&gt;

&lt;p&gt;其中整数部分，125=111101&lt;/p&gt;

&lt;p&gt;小数部分，0.125=0.001&lt;/p&gt;

&lt;p&gt;所以125.125=111101.001=1.11101001x2^5&lt;/p&gt;

&lt;p&gt;最后，来看一下125.125按照单精度的存储方式，它的实际存储数据是：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;符号位(1位)&lt;/th&gt;
      &lt;th&gt;指数部分(8位)&lt;/th&gt;
      &lt;th&gt;小数部分(23位)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;01111010&lt;/td&gt;
      &lt;td&gt;11101001000000000000000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;因为是正数，符号位为0；指数是5，5+127=132=1111010；小数部分，因为科学记数法的整数一定是大于0的，所以2进制下直接记录小数部分即可，在这里就是11101001&lt;/p&gt;

&lt;h3 id=&quot;浮点数定义0infnan&quot;&gt;浮点数定义:0/INF/NAN&lt;/h3&gt;
&lt;p&gt;IEEE754里对0/INF/NAN分别做了定义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/zhouhaijun-pic/2022/float-def-nan-inf.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按照IEEE754的描述，有几种特殊情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;指数全为0，小数部分全为0，这里要注意的是，按照IEEE754的标准，会存在一个小的问题，那就是浮点数会有+0和-0的区分；&lt;/li&gt;
  &lt;li&gt;指数全为1，小数部分全为0，符号位为0表示+Inf，正无穷大，符号位为1表示-Inf，即负无穷大；&lt;/li&gt;
  &lt;li&gt;指数全为1，小数部分不全为0，这种表示的是NAN，即非数字，not a number；
另外，这里需要注意的是，当遇到浮点数除0、负数求平方根的情况下，结果就是NAN。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;浮点数除零&quot;&gt;浮点数除零&lt;/h3&gt;
&lt;p&gt;整数除0是会引发错误，但是浮点数除0却不是一个错误，为什么IEEE 754里要这么规定呢？这里官方也给出了一个解释：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/zhouhaijun-pic/2022/float-divide-by-zero.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;IEEE  754对浮点数定义的场景较多，不局限于数学运算，还有电子表格、数据库的数据，所以标准里才有了INF/NAN的定义。&lt;/p&gt;

&lt;p&gt;最后再来看一下c++里的浮点数除零的几种场景：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;float c = 0.0 / 0.0;   // nan
float c = 1.0 / 0.0;   // inf
float c = -1.0 / 0.0;  // -inf
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://mathcenter.oxford.emory.edu/site/cs170/ieee754/&quot;&gt;IEEE 754标准&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://web.archive.org/web/20180112211305/http://grouper.ieee.org/groups/754/faq.html#exceptions&quot;&gt;why float dividing by zero is not a error?&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://baseconvert.com/ieee-754-floating-point&quot;&gt;浮点数10进制转2进制工具&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 13 Aug 2022 21:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/08/13/float-by-zero/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/08/13/float-by-zero/</guid>
        
        <category>计算机原理</category>
        
        
      </item>
    
      <item>
        <title>性能优化常见方法(1)</title>
        <description>&lt;p&gt;做性能优化也有方法论，如下几个步骤：&lt;/p&gt;

&lt;h3 id=&quot;建立性能测试基准&quot;&gt;建立性能测试基准&lt;/h3&gt;
&lt;p&gt;当你着手准备做性能优化工作之前，第一件事是建立性能测试的基准，为了后面的一系列优化定一个基准测试值。&lt;/p&gt;

&lt;h3 id=&quot;找到性能瓶颈点&quot;&gt;找到性能瓶颈点&lt;/h3&gt;
&lt;p&gt;借助工具，比如vtune或者perf，量化每个阶段的耗时，从而快速找到性能热点。
首先不能依赖自己的直觉或者经验，因为现代软件都是很复杂的，从cpu硬件、编译器、编程语言、各种软件框架，内部的细节实在太复杂，我们自以为是的经验或者直觉往往可能与现实背道而驰。所以我们做性能优化时，一定要有数据支撑，避免在反向优化的道路上越走越远。
这里有几个小工具挺好用的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;转换c++语言为汇编语言，可以看到机器具体的指令&lt;/p&gt;

    &lt;p&gt;https://godbolt.org/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一个是测试性能的，可以用来对性能优化工作做量化的一种工具&lt;/p&gt;

    &lt;p&gt;https://quick-bench.com/#&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译器优化的代码，很方便的看c++模板编译后的指令&lt;/p&gt;

    &lt;p&gt;https://cppinsights.io/&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;问题描述和抽象&quot;&gt;问题描述和抽象&lt;/h3&gt;
&lt;p&gt;通过第二步，借助工具，已经可以找到性能热点了，下一步就是对问题进行描述、归纳总结和问题抽象。
举个例子来说:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// find &lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// not find&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;    
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述这段代码，如果发现热点在find，接下来要去思考几个点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过这段代码，我们了解到，它想要做的就是基于一个string去查找对应的key值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题抽象:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基于上述问题描述的过程，抽象总结成一句话：基于文本值去查找对应的key。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;搞清楚原理：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;热点既然是在find函数，那进一步的，我们要搞清楚，为什么热点是这里，所以我们要深挖一下背后的工作原理，find的具体工作过程是怎样的？&lt;/p&gt;

&lt;p&gt;比如说我们这里的查找过程：传一个string对象，然后在table里通过二分查找，依次与表里的元素做比对，遍历完整个表。&lt;/p&gt;

&lt;h3 id=&quot;问题拆解算法数据结构&quot;&gt;问题拆解：算法、数据结构&lt;/h3&gt;
&lt;p&gt;有了上述到数据和问题分析，我们再进一步思考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;从优化算法的角度考虑&lt;/p&gt;

    &lt;p&gt;map的底层实现是一个平衡二叉树，查找平衡二叉树的算法时间开销是O(logN)，那思考一下，有没有更高效一点的算法？可以考虑一下散列表。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从数据结构的角度考虑&lt;/p&gt;

    &lt;p&gt;使用string作为key，map在查找过程中，会内部构造一个string对象，那么是否可以考虑使用其他的key类型，比如char*。&lt;/p&gt;

    &lt;p&gt;无论是map还是unordered_map，本身都是非线形的数据结构，那么这种结构会导致CPU的cache miss，能不能考虑使用线形的结构？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;性能测试&quot;&gt;性能测试&lt;/h3&gt;
&lt;p&gt;最后一步，基于上述的修改，做性能测试，与第一步的基准测试做比较，观察性能优化是否有正向的效果。&lt;/p&gt;

&lt;p&gt;做性能优化也有方法论，自顶向下，一层层的拆解开来，跟计算机的递归程序一模一样。&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Aug 2022 16:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/08/10/performance-optimization-1/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/08/10/performance-optimization-1/</guid>
        
        <category>性能优化</category>
        
        
      </item>
    
      <item>
        <title>关于做好一件事的思考</title>
        <description>&lt;p&gt;关于做好一件事，其实我总结了一下，无非就是几个核心因素：&lt;/p&gt;

&lt;h3 id=&quot;正确的做事方法&quot;&gt;正确的做事方法&lt;/h3&gt;
&lt;p&gt;不管是通过网络、别人传授、还是自己总结开悟，总之一定要先找到正确的方法。
正确的方法可以提效，往往可以事半功倍，如果方法不对，就是事倍功半。道理就是这个道理，浅显易懂。&lt;/p&gt;

&lt;h3 id=&quot;总结思考和沉淀&quot;&gt;总结思考和沉淀&lt;/h3&gt;
&lt;p&gt;在阿里这边，我听到的最多的就是“要思考、要总结、要沉淀”，这一点上我认为是对的。
如果不总结不沉淀，就没法形成自己的一套思考体系，那么下次遇到类似的问题、人、事上，就没办法复用之前的经验，可能还是在做一部分无用功，会走弯路。&lt;/p&gt;

&lt;h3 id=&quot;实战&quot;&gt;实战&lt;/h3&gt;
&lt;p&gt;剩下的就是在事中练，其实道理都很简单，往往到了这一步，靠的就是自驱能力。
我觉得总结一句话，就是用高标准的去要求自己：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;做完一项工作，一定要再问问自己，还有没有更好的方法、路径？&lt;/li&gt;
  &lt;li&gt;自己在这个过程中，有哪些做的不好的地方，还能不能在改进呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用这种态度去要求自己，不断总结、思考和优化，那么不管是写代码、还是做产品，我觉得都应该有一定的好的效果。&lt;/p&gt;
</description>
        <pubDate>Sat, 06 Aug 2022 18:00:00 +0800</pubDate>
        <link>http://localhost:4000/2022/08/06/thinking-about-good-way/</link>
        <guid isPermaLink="true">http://localhost:4000/2022/08/06/thinking-about-good-way/</guid>
        
        <category>感悟</category>
        
        
      </item>
    
      <item>
        <title>关于从事编程工作的思考(一)</title>
        <description>&lt;h3 id=&quot;写在前面&quot;&gt;写在前面&lt;/h3&gt;

&lt;p&gt;温馨提示，这篇文章更像是杂谈，早晨醒来的时候，躺在床上，一些东西闪过脑海，灵感也好思考也罢，就当是一种思考记录下来。&lt;/p&gt;

&lt;p&gt;下面开始正文：&lt;/p&gt;

&lt;p&gt;我个人认为，要想做好软件编程这项工作，并想在这个领域取得一些成绩，应至少具备两个方面的素质：一是在技术上有良好的产出，并在产品落地的过程中解决各种疑难杂症；二是应当具备良好的沟通表达能力，解决技术之外的各种沟通问题。&lt;/p&gt;

&lt;h3 id=&quot;技术能力&quot;&gt;技术能力&lt;/h3&gt;

&lt;p&gt;我把技术能力分成三个维度：编码、调试和软件设计。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;代码能力&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;写出实现产品功能的代码不难，难的是写出高扩展性、可维护性的代码。这一点并不难理解，产品是需要不断的向前迭代，在这个过程中，每个公司、部门、乃至个人都在追求更快的生产速度，但是要知道天下没有免费的午餐，产品迭代越快，代码就呈线性增长，代码体积增大到一定程度就会面临各种问题，比如兼容性问题，在实现新需求上就要考虑历史需求的功能兼容性问题，越复杂的需求引入bug的概率就会越高，甚至出现新需求与历史功能相矛盾的地方。&lt;/p&gt;

&lt;p&gt;也就是说，要写出好的代码，不单单是把编程语言这门工具玩熟这么简单，还需要关注软件业务本身，只有从场景出发，才有可能写出具备扩展性的代码。这也很好解释，比如说假如一家新公司或者一个新项目组，需要接手别人产品时，通常都是先搞清楚业务模型再来看代码，搞清楚大基调再深入代码细节就容易的多。&lt;/p&gt;

&lt;p&gt;总结一句，好代码背后体现的是对产品和技术的一个思考和权衡，代码是最外层的直观体现，背后牵扯到的是对产品业务、代码重构等一些列的思考。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调试能力&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;产品上线后总会遇到一些奇奇怪怪的线上问题，程序员需要做的就是尽可能快地找到问题的根结，并快速消灭bug。&lt;/p&gt;

&lt;p&gt;有一点需要搞清楚，业务软件是最上面的一层软件，底座是是操作系统、网络、数据库、硬件，产品出问题也不仅仅只有功能出问题，也有可能是使用的姿势不对，导致底层的软件出现“逻辑泄漏”。如果对这些底层知识了解的不够深入，往往定位问题时会一头雾水，没有头绪，最终会导致调试、定位问题效率低下。&lt;/p&gt;

&lt;p&gt;也就说调试能力也是外在的体现，想要获取良好的调试及问题定位能力，掌握一些工具是很有必要，但这些工具都是“术”，背后的“道”则是要对底层原理知识有深入的了解，只有对这些底层原理知识有认真的研究，并将底层原理知识由点、线、面的串连起来，才能构建出自己的核心知识体系，进而在问题调试和定位上就会容易很多。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;软件设计&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;程序员不可能永远做产品修修补补的工作，肯定会遇到新的模块或新系统的设计，尤其是经验丰富的资深程序员，会接触到一些比如重构老系统模块，设计新系统等工作，所以对软件的设计能力要求高，我们要追求的不仅仅是落地产品功能，更要关注一些内部指标，比如服务可用性等问题。&lt;/p&gt;

&lt;h3 id=&quot;沟通表达能力&quot;&gt;沟通表达能力&lt;/h3&gt;

&lt;p&gt;沟通协作是一项软技能，也很重要，尤其是在一些“变”的场景下，比如讨论产品需求、产品规划、会议讨论某个专项、协作开发等等，沟通的技巧涉及的点太多，但我以为只要把握最关键的一点即可，那就是从整体的全局性目标出发，尽可能地将个人目标与团队目标、公司目标达成一致，并不断地增大两者的重叠面积。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;程序员最重要的是做实事的能力，应用到工作上，那就是技术能力，同时掌握一些沟通技巧，那么在应对编程这项工作上就会比较稳一些，当然如果想要一些突破性的成绩，可能还得有一个能拿得出手的领域专项，比如智能算法设计、后端大数据等等。&lt;/p&gt;
</description>
        <pubDate>Wed, 20 Oct 2021 05:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/10/20/thinking-about-programing/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/10/20/thinking-about-programing/</guid>
        
        <category>感悟</category>
        
        
      </item>
    
      <item>
        <title>内存对齐</title>
        <description>&lt;h3 id=&quot;术语定义&quot;&gt;术语定义&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;naturally aligned&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考自http://books.gigatux.nl/mirror/kerneldevelopment/0672327201/ch19lev1sec3.html&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A variable is &lt;em&gt;naturally aligned&lt;/em&gt; if it exists at a memory address that is a multiple of its size. For example, a 32-bit type is naturally aligned if it is located in memory at an address that is a multiple of four (that is, its lowest two bits are zero). Thus, a data type with size 2&lt;em&gt;n&lt;/em&gt; bytes must have an address with the &lt;em&gt;n&lt;/em&gt; least significant bits set to zero.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当访问一块N字节的内存变量时，若访问的内存地址能被N整除，则称该内存地址是 naturally aligned。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;data alignment&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考自https://en.m.wikipedia.org/wiki/Data_structure_alignment&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Data alignment is the aligning of elements according to their natural alignment. To ensure natural alignment, it may be necessary to insert some padding between structure elements or after the last element of a structure. For example, on a 32-bit machine, a data structure containing a 16-bit value followed by a 32-bit value could have 16 bits of padding between the 16-bit value and the 32-bit value to align the 32-bit value on a 32-bit boundary. Alternatively, one can pack the structure, omitting the padding, which may lead to slower access, but uses three quarters as much memory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举例来说，在linux x86平台下，定义了如下的结构体：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;struct mystruct {
    char c; // 1 byte
    short s; // 2 byte
    int i; // 4 byte
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;按照上述&lt;em&gt;naturally aligned&lt;/em&gt;的定义，如果要访问占用1字节的c的内存地址，无论如何都是naturally aligned，但此时访问占用2字节的s却无法满足naturally aligned，解决的办法就是在c后面插入1个字节(也叫padding)，使得c和s一共占用4字节，而对于i来说，刚好也满足naturally aligned，这样一来结构体的所有变量内存地址就都满足naturally aligned，我们称这样的结构体为data alignment。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;memory access granularity  vs  memory access boundary&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考自https://stackoverflow.com/questions/16620226/double-byte-memory-access-granularity&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Memory access granularity&lt;/em&gt; is the number of bytes it accesses at a time, and a &lt;em&gt;memory access boundary&lt;/em&gt; is where each of these groups of bytes begins.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;cpu需要从内存加载数据，那么cpu访问一次内存获取的数据大小，称之为memory access granularity，单位是byte，比如68000下是2字节，68030 和PowerPC® 601是4字节。&lt;/p&gt;

&lt;h3 id=&quot;什么是内存对齐&quot;&gt;什么是内存对齐&lt;/h3&gt;

&lt;p&gt;有了上述&lt;em&gt;naturally aligned&lt;/em&gt;和&lt;em&gt;data alignment&lt;/em&gt;的定义，便不难理解什么是内存对齐，这里举出一个反例：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    char dog[10];
    char *p = &amp;amp;dog[1];
    unsigned long l = *(unsigned long *)p;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述代码里，指向char的指针被强转为unsigned long型，此时访问变量l，便有可能会造成内存不对齐的问题。&lt;/p&gt;

&lt;h3 id=&quot;为什么需要内存对齐&quot;&gt;为什么需要内存对齐&lt;/h3&gt;

&lt;p&gt;一般的，编程中大多数内存不对齐的问题都会在编译器这一层解决了，但是出于好奇，我们也会想知道为什么要做内存对齐，或者说内存对齐带来了哪些好处？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;访问速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假设我们现在用的是PowerPC® 601，其memory access granularity是4字节，（下图来自https://developer.ibm.com/technologies/systems/articles/pa-dalign/)是分别从0x0和0x1读取4字节的示意图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/zhouhaijun-pic/memory_alig_1.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看出，当从地址0x0读取4字节只需要一次读取即可，但是从地址0x1读取4字节，就需要2次，具体过程如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/zhouhaijun-pic/unalignedAccess.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;第一步从0x0读取4字节，获取字节0x1~0x3；&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;第二步从0x4读取4字节，获取字节0x4；&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;两次读取后的数据再做一次聚合；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由此得知，内存不对齐会导致访问内存的频次变高，一是降低了访问速度，另外一个是增加了总线带宽的消耗。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;原子性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当前的很多处理器都提供了一些原子操作的指令，在使用这些指令去访问内存时，如果提供的地址没有满足内存对齐，会导致的访问的内存变成多次，进而原子的语义就会被破坏。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;兼容性问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在x86的平台下我们借助pragma指令可以强制编译器修改默认对齐字节数，是因为x86的处理器可以访问不对齐的内存，但在其他的处理器上，例如68000 下cpu访问不对齐的地址时会抛出异常，在Sun SPARC下访问未对齐的内存程序会crash。&lt;/p&gt;

&lt;h3 id=&quot;结构体内存对齐规则&quot;&gt;结构体内存对齐规则&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;对齐规则&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;N=min(结构体最宽的成员大小，指定编译器对齐大小)，注意制定编译器对齐大小只能是2的幂，比如1、2、4字节，实际编程中尽量不要使用pragma来制定编译器对齐大小，可能会导致不同平台下的兼容性问题：&lt;/p&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;结构体变量的起始地址能够被N整除；&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充字节；&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;
    &lt;p&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;结构体总体大小能够被N整除，如不能则在后面补充字节；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;实例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;定义如下结构体，在linux  x86平台下的内存布局为：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;struct mystruct {
    bool a;
    // 为确保访问b的内存对齐，此处插入1字节
    short b;
    // 为确保访问c时内存对齐，此处插入4字节
    long long c; // 成员变量最宽字节数，8字节
    bool d;
    // 为确保数组元素的下一个结构体首地址内存对齐，此处插入7字节
};
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;

&lt;p&gt;内存对齐&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;https://developer.ibm.com/technologies/systems/articles/pa-dalign/&lt;/li&gt;
  &lt;li&gt;https://en.m.wikipedia.org/wiki/Data_structure_alignment&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么memory access boundary is power of 2&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;https://stackoverflow.com/questions/64415023/why-cpu-accesses-aligned-memory&lt;/li&gt;
  &lt;li&gt;https://stackoverflow.com/questions/3655926/why-does-cpu-access-memory-on-a-word-boundary&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 16 Oct 2021 05:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/10/16/memory-alignment/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/10/16/memory-alignment/</guid>
        
        <category>内存对齐</category>
        
        
      </item>
    
  </channel>
</rss>

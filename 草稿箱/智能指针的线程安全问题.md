

### 背景

在智能指针出来之前，c++工程师都是自己手动管理内存的：使用new/malloc分配的内存空间，在模块或函数使用完内存后一定要手动调用delete/free释放资源。所以c++工程师在使用内存时是很谨慎的，这种工作虽然烦琐，但一旦使用不当就会容易引发内存泄漏问题，通常这类问题到了线上都会成为工程师的噩梦，尤其是软件规模庞大、内部逻辑错杂复杂的情况下，这种问题定位起来就更加困难了。

那有没有一种解决方案，可以解决这种繁琐的内存管理问题呢？计算机领域有一句名言：

> 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决

实际上在内存管理这块也是适用的，它就是智能指针，英文名为smart pointer。



### 工作原理

在介绍工作原理之前，先来看一下智能指针的内部结构，内部被分为两个部分：一个是引用计数器，另一个是指向真正的内存地址，像下面的这幅图这样：

![smart_pointer](/Users/navychou/Project/github/blog/images/smart_pointer.jpg)



智能指针之所以能动态管理内存，靠的就是引用计数器，我们以shared_ptr为例，通过一段代码来解释下其内部的工作原理：

```c++
    // 构造一个智能指针对象p: 对象地址指向的是一个int变量，此时计数器为1
    std::shared_ptr<int> p = std::make_shared<int>(100);

    // 此时智能指针对象p内部的引用计数加一，但p1和p指向的内存对象都是同一个:对象地址没有变化，但计数器变为2
    std::shared_ptr<int> p1(p);

    // 此时智能指针p：对象地址没有变化，但引用计数变为1
    p1.reset();

    // 引用计数变为0，内存立即释放
    p.reset();
```



### 线程安全

有了上面的背景，我们开始今天的话题，即智能指针的线程安全问题。

我之前一直以为智能指针不是线程安全的，所以在多线程里但凡使用到智能指针，基本都会加锁。今天看到一篇关于shared_ptr的文章，重新引起了我的思考，其中几句关键的话我贴在下面 (完整的链接我放到文末附录)。

> `shared_ptr` objects offer the same level of thread safety as built-in types. A `shared_ptr` instance can be "read" (accessed using only const operations) simultaneously by multiple threads. Different `shared_ptr` instances can be "written to" (accessed using mutable operations such as `operator=` or `reset`) simultaneously by multiple threads (even when these instances are copies, and share the same reference count underneath.)

也就是说，智能指针跟c++语言里其他的内置类型一样：对于同一个智能指针对象，可以被多线程读取；对于不同的智能指针对象，那么也可以被多线程同时写，哪怕这些不同智能指针指向的是同一块内存，我们以一个int类型的变量举例来说：

```c++
// 定义一个全局变量
int data = 100;

// 场景一：线程A和线程B同时读取变量data
{
    // 线程A
    int a = data;

    // 线程B
    int b = data;
}

// 场景二：线程A和线程B同时对读取的变量做写操作处理
{
    // 线程A
    int a = data;
    a = 200;

    // 线程B
    int b = data;
    b = 300;
}

// 场景三：线程A读取data变量，线程B写data变量
{
    // 线程A
    int a = data;

    // 线程B
    data = 500;
}
```

很明显的，上面的场景一和场景二都是线程安全的，场景三不是线程安全的。



好了，我们继续把注意力放到智能指针对象上，先来定义一个全局的智能指针：

```c++
shared_ptr<int> p(new int(42));
```

- 场景一：多线程读

  ```c++
  // thread A
  shared_ptr<int> p2(p); // reads p
  
  // thread B
  shared_ptr<int> p3(p); // OK, multiple reads are safe
  ```

  线程A和线程B同时读取p，内部都是引用计数加一的操作，不涉及内存释放，而且因为引用计数是原子操作，所以是线程安全的。

- 场景二：多线程写

  ```c++
  // thread A
  p.reset(new int(1912)); // writes p
  
  // thread B
  p2.reset(); // OK, writes p2
  ```

  线程A写变量p，线程B写变量p2，虽然p和p2指向的是同一个内存对象地址，但实际上p和p2是两个不同的智能指针对象，同时因为引用计数操作是原子操作，同一时刻只可能有一次内存释放，所以也是线程安全的。

- 场景三：多线程读和写

  ```c++
  // thread A
  p = p3; // reads p3, writes p
  
  // thread B
  p3.reset(); // writes p3; undefined, simultaneous read/write
  ```

  线程A读变量p3，线程B写变量p3，虽然p3的引用计数是原子操作，但多线程同时读写变量会引发一个bug：上述的场景三里，如果线程B先于线程A执行，当线程B执行完p3.reset()，智能指针p3就有可能把其指向的内存资源释放了，此时线程A从变量p3中读取的变量p，其指向的内存可能已经被释放了，所以场景三不是线程安全的。



### 总结

c++语言里，多线程里对同一个智能指针对象或内置变量、类对象的读写都是不安全的，但引发线程不安全的底层原因却是不一样的：

- 内置变量、类

  多线程读写内置变量，如int、double等，之所以线程不安全，是因为针对同一个内存的数据读和写操作不是一个原子操作。

- 智能指针

  多线程里对同一个智能指针对象的读写(这里的读写智能指针，指的是赋值、reset等操作)，其内部的引用计数虽然是原子操作，但内存释放和引用计数却是两个不同的操作，这就有可能会导致内存

总结一句话，实际使用中，对于智能指针的读，是线程安全的，涉及到多线程的写操作，最好是对智能指针对象加锁，避免不必要的内存问题发生。



### 附录

[boost shared_ptr thread safety](https://www.boost.org/doc/libs/1_73_0/libs/smart_ptr/doc/html/smart_ptr.html#shared_ptr_thread_safety)


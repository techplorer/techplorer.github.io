起因是组内的同事在c++项目中引入conan的开源库，引起了我的兴趣，于是我就在网上去查了一些相关资料。

第一次接触二进制包管理器时，我认为要实现这样的工具，无非就是将库名称、库实体以及库版本号找一个地方集中式管理，对客户端开放下载能力，似乎也没什么特别难的地方；但经过一番资料查询和深入思考后，发现其实要做二进制数据管理，要解决的问题也没那么容易，要解决的问题有：

- 库的线形依赖，比如说库a->b->c，当客户端下载库a时，同时提供依赖文件下载；
- 当依赖路径出现同一个库的不同版本时，如何处理冲突；
- 如果是集中式的管理二进制数据，当一旦客户端数量达到一定规模，中心服务端就会出现瓶颈；

### 库依赖问题

库的线形依赖会简单一些，只要在服务端存放库文件的地方，放上一份依赖关系说明，当客户端下载库文件后，将对应的依赖文件也一并下载。 但是这里有可能会引入循环依赖的问题，比方说下面的这个依赖关系：

- a--->b--->c--->a

### 依赖库版本冲突问题

项目中有一种场景，比如说下面当这个依赖关系：

- a--->b--->1.0.0 c
- a--->d--->1.2.0 c

库a的依赖关系路径里同时存在对不同版本的c有依赖，这个时候程序a依赖的程序库c同时出现1.0.0和1.2.0的版本，这种冲突问题该怎么解决呢？

### 性能问题

当客户端的规模达到一定数量级别，中心服务的并发就会容易达到瓶颈，要解决这个问题，一般是有两种方案：一种是将中心服务改为分布式，这种对中心服务的要求会比较高；另外一种是通过客户端缓存，缓存一定时间内的库，这种方案会在一定程度上减少对中心服务的使用频率，但是与此同时也带来了客户端的缓存与中心服务的同步问题。

### 总结

总结一下，二进制包管理的实现不仅要考虑对二进制文件的下载，还要考虑文件之间的依赖关系，如果考虑的再细致一些，还要考虑如何避免循环依赖以及依赖版本冲突的问题。
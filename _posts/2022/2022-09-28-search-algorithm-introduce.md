---
layout:   post
title:   "检索算法基础知识"
subtitle:  ""
date:    2022-09-27 22:00:00
author:   "zhouhaijun"
catalog: false
header-style: text
tags:
 - 搜索与推荐
---

检索算法的基础知识点，从数据结构和算法两个方面总结：
### 线性结构检索

线性表，也就是数组，它的特点是数据连续存储，可以做到随机访问，数组排好序的前提下可以用二分法实现O(logN)的查找速度，缺点就是元素增删会导致数组扩容、重新排序，是会影响检索效率。

### 非线形结构检索
以单链表来说，它的特点是数据离散存储，增删操作不会有类似数组扩容的问题，但无法像数组那样做到随机访问。

查找元素的复杂度是O(N)，但是我们也可以用二分法的思路来提速，这就涉及到二叉搜索树和跳表，查找时间复杂度提升到O(logN)。

这样看起来的话，似乎二叉搜索树、跳表的实现要优于数组，但是在实际的工程里边，因为CPU局部性原理，连续数据的存储，在查找效率会比离散结构的高，因为数据离散，导致CPU cache miss的可能性也就越高。所以在小数据量的场景下，数组往往是一个更优的选择。

### 哈希表

无论是有序数组还是二叉搜索树，查找速度都是O(logN)，有没有更快的检索算法呢？哈希表就是这么出来的，实现思路也很简单：设计一个散列函数(或者叫哈希函数)，建立key到数组下标的映射，再配合数组的随机访问的特点，可以实现O(1)的查找。

但是哈希表也要处理一个棘手的问题，不管哈希函数设计的多么好，哈希冲撞是一件必然发生事件。所以哈希冲撞是一个绕不开的问题，处理哈希冲撞的解决方案目前主要有两种：开放地址和链表法。

了解内部原理，其实也就能发现，哈希查找O(1)是一种理想值，往往具体的过程是这样：以链表冲突法为例，通过哈希函数找到对应的bucket桶，再对链表做一次遍历，这样下来查找效率往往没有O(1)，更何况还得考虑CPU cache miss的情况。

这里也可以再引申一下，哈希的结构优化，以链表法冲突为例，为了加速查找，可以考虑设计一个阈值，在小于一定阈值的情况下用链表存储冲突元素，当大于一定阈值，将链表改为平衡树。

### 位图

我们还会遇到一种比较常见的场景：在海量的大数据，想要尽可能快的查找一个元素是否存在，比如新用户注册id、网络爬虫URL判重等。

在这种场景下，如果用哈希表存储，最大的问题在于存储效率，举例来说，如果要存储100亿个uint32的数据，得有37.2GB的存储空间，所以这里的逻辑在于：有没有一种结构，可以实现O(1)的查找，同时存储空间尽可能的小？

位图就是这么来的，它的一个实现方案是：用一个连续的数组来存储，每一个bit通过0和1区分元素是否存在，使用一个哈希函数将元素映射到数组下标。采用这样的思路，同样是1亿个uint32的数据，我们只需要1.16GB，存储空间只有原来的3%。

进一步的，位图的数据如果是不稠密的话，空间上还可以再压缩一下，常见的方案是roraing bitmap。
